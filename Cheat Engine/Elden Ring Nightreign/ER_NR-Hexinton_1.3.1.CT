<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="46">
  <Forms>
    <BulletLogForm Class="TCEForm" Encoding="Ascii85">ZIaJ!,CUJ-2RmRJ15%]3:(1,Jh@l;oV1k0]2n)#[SQ(eORhC[{9+2/EiTVP*[ugxtr/bn)L6CYG=e5HeJHKzIVFHA}bYz9z=Nq8:cbsvK/jYOIyYg^OX8gBxhitPY@N)SMa(P^I/_9jJYyL92H!-ni@rRpqxz)/(vy=0@,7pwa*ho_F-Alnps+cAQ3OXse/-QhddXh[ZH5d$[JHeD}M96j,1T+8MH/8)j/2YNdQDNe:r}1]lQEyo;f7}+^[FR0!W1uiit(bNh-{6xCJ[M1^k6sGeZQt]BP@Ed-*_cVe.b:GlS38sQJTN?G!z-+Ypmyf1aK//rQ+reBeX#U0,ljQ-IC/h!p3ElIg]WTo]z9l}WUuI*;YB041eG/$X8@a9)w4/fwtJs)VoT(0lVdM1O6Gze9cLjA@/fyT/_.vDfE]N7L$+)CCns6bk*vflrwiOmMWFK/Gg:_/7P0JaHYqVX6^c{r^QnQ5=(v;2ZfR_SZv+6mb):8i/l$0vTC4U8*wfF3JiIsW%youo+qU!ik/uUF:%tThqq}9Y5MSty3CaiKG#6tY#ZMQh627%g$C4*i?DB</BulletLogForm>
    <EffectLogForm Class="TCEForm" Encoding="Ascii85">=N-rl,AtI}NlOTnYMrzPrakPT)w-XGA%Wzvg]%=26.aeqdzsQ:Xtt1]#I$9/RqX?z1JnLuKQU;u9SC%SV5DhJvt-MO(pr2@Ydg7nMF6[)22^GW/3/n.i@u(wz9y_.z?D}RxKCv8Gkb#F!3}jrNOCtA$zQ=trQ0Jn@2bc@?S3:^xEA.%3[K-2HFqPT*SMA/13$YPzk7Ka[$};.oto!jpCpWh[/2UST=?P+,{hvY2gN#$,:1V9hq(EtO85B(@]h}0MY.AaZ)M?(XZ^.JX??w9l.:ld(%=9WKd?o8mT%Qs7dVVqJW5$JG@jyPpqg2v7cRbA2%L,Sz*bT4+DTE=Pa]aqN/g90?z9TUGl@Pts/v5:4W##AzL:_zLx.]gYwDp#H4bS8lwIO/n9JAWh]9YpVkKWR-c1eK02G?94/oJRe6Bmh$v.y8U;yPgel0YKKC@CAp3o6$2+wQ:HbgpGIY7)sWh9Q?qTRGDD02)A9F)P/lc7{DHtn].A.cyKt.BJk$b:h439St+l8]H?A.-kJxmJD@QrLR:hOV#i$WUd71X9UR]qLN%=YLE_6}odi:_+KCYC^NR3ZcX#SA_fPz*^qZz:/@th$]tYnQy-;azrXZVL]F5%:A/!v^(eEn?Re45M;+#?+C=cYi4=QHWc+B*tXbkmSHX1EOxzg20,!cJ+77y(I.0ChB.W}*iTi9JHcZyHu)rJI-?M}ZPN_GPoN-77db9a7lW-yOq?UyisIHKI(mwgwJOAhgxF9O3fx93T;$=Hnw$PCbY$?Jet=$o^%]-j6.8)/anG=wt1(g#!A_eY[a;@@3GQYuyUx^F+u$X(a?];Cy6z}-sjM12Cle1Vx!b6NM=pvcU8kj?bA]PkALAOYS$_wAN[*II^vu6[HMFECEVP{F*[S}z%,Xs#d5=Q8+/r)D+0)d)5?(swvdS,O3)(c*xtL6j;N[V,NF!6{w1xcvjRx#;?jW=leZtD/q;4WBoa.{ImSXYQesmOgy#=ucKGIrrh3?Y(-LDeeS(CjQT4lom-ye#/2]iTVu43;T</EffectLogForm>
    <AttackLogForm Class="TCEForm" Encoding="Ascii85">ZIaDy8Zi+Zy}}GpArSRc)Nhnc5mNgCumpv6Q(zA[q,Y5GJAhSVBYQ{}dn8h=d4Z}L*LYd/*Mu!?A0$-uVPtzW_M}yy]RNi8N8;)=gR],zo7Mm@S$qxU%ATqrEV1(fT0aN2T4TkmSZ+tiPVI]NxUNi^*=k6]1[CKiNlqI?InzjkWQ$CSdON;,dm#lwsZIjUK.S^KnV)C,S_GVp*o!.-S_iYGC1SRLD4Mu.jj]#^%kq;i[_:+rG@XMs;;}wQ);KE%:YWOxFE+69Mi[+bptSWv-{T:2]n@7B8fNSClELi?.}BI_O6DimGP_VqkHb!/L#WyAHbS=Z1Fc]sPDVw,Jt2-i.09!4Flif.nbrNU*5w/lLtXv%[s3rkKk[2=Ga:239Y.0=4h![X86?dc?V*QP/ZXEwC*ZPzf@vx$OUYxl*t,x?:D6oTy(FA*tyD-%-k;Jez+__(Jx*f*sP1X?yMNrmME@ff%[va?BYOgm5IZ)!DZ;+Rj#WREs.?KEr$V+jynMiCu4fp;GkkMQlyT.pZ3tpz,;lo;,}GMBXvg3%1w)Fn9.I@l]ce-iPYEG@0R</AttackLogForm>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>12</ID>
      <Description>"启动郊狼 (双击右侧&lt;脚本&gt; 设置电量)"</Description>
      <Color>4080FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
local coyote_controller_url = "http://127.0.0.1:8920/" -- 控制器地址，本地使用时无需修改
local coyote_target_client_id = "all" -- 填写你的客户端ID，本地使用时使用"all"即可

-- 以下配置如果需要禁用，可以将对应的值设置为nil
local reduce_HP_increase_strength = 0.1 -- 每减少一点HP增加的强度
local reduce_HP_fire_strength = 15 -- 减少HP时一键开火的强度（会与增加强度叠加）
local reduce_HP_fire_time = 5 -- 减少HP时一键开火的时间（秒）
local increase_HP_reduce_strength = 0.1 -- 每增加一点HP减少的强度

local level_up_set_strength = 10 -- 每回合胜利设置的强度

-------------------------------------------------------------------------------
-- 以下为 Coyote-Streaming-Widget SDK
-------------------------------------------------------------------------------
-- 更新游戏配置，参考api.md中的"设置游戏强度配置"
-- @param param_str string query格式的参数字符串
local function coyote_update_game_config(param_str)
    local http = getInternet()

    local api_url = coyote_controller_url .. "api/game/" .. coyote_target_client_id .. "/strength_config"
    local response = http.postURL(api_url, param_str)

    return response
end

-- 增加强度
-- @param value number 强度值
local function coyote_add_strength(value)
    local param_str = "strength.add=" .. value
    return coyote_update_game_config(param_str)
end

-- 减少强度
-- @param value number 强度值
local function coyote_sub_strength(value)
    local param_str = "strength.sub=" .. value
    return coyote_update_game_config(param_str)
end

-- 设置强度
-- @param value number 强度值
local function coyote_set_strength(value)
    local param_str = "strength.set=" .. value
    return coyote_update_game_config(param_str)
end

-- 增加随机强度
-- @param value number 强度值
local function coyote_add_random_strength(value)
    local param_str = "randomStrength.add=" .. value
    return coyote_update_game_config(param_str)
end

-- 减少随机强度
-- @param value number 强度值
local function coyote_sub_random_strength(value)
    local param_str = "randomStrength.sub=" .. value
    return coyote_update_game_config(param_str)
end

-- 设置随机强度
-- @param value number 强度值
local function coyote_set_random_strength(value)
    local param_str = "randomStrength.set=" .. value
    return coyote_update_game_config(param_str)
end

-- 一键开火
-- @param strength number 强度值
local function coyote_fire(strength, time)
    time = time or 5
    time = time * 1000
    local http = getInternet()
    local param_str = "strength=" .. strength .. "&amp;time=" .. time
    local api_url = coyote_controller_url .. "api/game/" .. coyote_target_client_id .. "/fire"
    local response = http.postURL(api_url, param_str)
    return response
end

-------------------------------------------------------------------------------
-- 以下为Cheat Engine脚本部分
-------------------------------------------------------------------------------
local varname_health = "血量" -- 血量
local varname_max_health = "最大血量上限" -- 最大血量
local varname_level = "等级" -- 等级

local current_level = -1 -- 当前回合
local max_health = -1
local in_game = false -- 是否在对局中

local function is_game_start(newvalue)
    <!-- if not newvalue then return false end -->
    return current_level == 1 and newvalue &gt; 0 and newvalue &lt; 1000
end

local function get_memoryrecord_value(description)
    for i = 0, AddressList.Count - 1 do
        local memoryrecord = AddressList[i]
        if memoryrecord.Description == description then
            return memoryrecord.Value
        end
    end
    return nil
end



-- 监听血量变化
local function on_health_changed(memoryrecord, oldvalue, newvalue)
    oldvalue = tonumber(oldvalue)
    newvalue = tonumber(newvalue)

    if not newvalue then
        in_game = false
        return
    end

    if not in_game then
        if is_game_start(newvalue) then
            -- 等级为1且血量大于0时，游戏开始
            createNativeThread(function()
                sleep(500)
                print("游戏开始")
                in_game = true
            end)
        end
        -- 不在对局中，不处理
        return
    end

    if not oldvalue then
        return
    end

    local max_health = get_memoryrecord_value(varname_max_health)
    local delta = (newvalue - oldvalue) / tonumber(max_health) * 100
    if delta &gt; 0 and oldvalue &gt; 0 then
        -- 增加血量
        print("增加血量百分比：" .. delta)
        if increase_HP_reduce_strength ~= nil then
            -- 增加血量时减少强度
            local strength = increase_HP_reduce_strength * delta
            print("减少强度：" .. strength)
            coyote_sub_strength(strength)
            
        end
    elseif delta &lt; 0 then
        -- 减少血量
        print("减少血量百分比：" .. math.abs(delta))
        if reduce_HP_increase_strength ~= nil then
            -- 减少血量时增加强度
            local strength = reduce_HP_increase_strength * math.abs(delta)
            print("增加强度：" .. strength)
            coyote_add_strength(strength)
        end
        if reduce_HP_fire_strength ~= nil then
            -- 减少血量时一键开火
            print("一键开火：" .. reduce_HP_fire_strength)
            coyote_fire(reduce_HP_fire_strength, reduce_HP_fire_time)
        end
    end

    if newvalue == 0 then
        -- 血量为0，游戏结束
        print("战败")
    end
end

-- 监听等级变化
local function on_level_changed(memoryrecord, oldvalue, newvalue)
    oldvalue = tonumber(oldvalue)
    newvalue = tonumber(newvalue)
    -- 等级
    print("当前等级：" .. newvalue)
            -- 每次升级设置强度
    print("您已升级，强度重置为：" .. level_up_set_strength)
    coyote_set_strength(level_up_set_strength)
    current_level = newvalue
end

local function init_listener()
    for i = 0, AddressList.Count - 1 do
        local memoryrecord = AddressList[i]

        -- 设置监听
        if memoryrecord.Description == varname_health then
            memoryrecord.OnValueChanged = on_health_changed
        elseif memoryrecord.Description == varname_level then
            memoryrecord.OnValueChanged = on_level_changed
        end
    end

    print("初始化完成")
end

if syntaxcheck then
    return
end

init_listener()
{$asm}

[DISABLE]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1</ID>
      <Description>"角色信息 (进入游戏后勾选)"</Description>

      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>{$lua}
-- a little adjusted by akira
if syntaxcheck then return end
[ENABLE]
function init()
   package.preload["ce"] = function(...)
     local _m = {}

     local STANDARD_MODE = 0
     local COMPACT_MODE = 2

     -- caption shows name of the next mode

     function _m:_update()
       AddressList.Header.Sections[2].Width=150
       AddressList.Header.Sections[3].Width=150
       --self.menu_item.Caption = captions[self.mode]
       -- splitter between Scanning panel and Address list
       MainForm.Splitter1.Visible = self.mode == STANDARD_MODE
       -- Status bar
       MainForm.Panel4.Visible = self.mode == STANDARD_MODE
       -- Scanning panel
       MainForm.Panel5.Visible = self.mode == STANDARD_MODE
       -- Address column in Address list
       AddressList.Header.Sections[2].Visible = self.mode == STANDARD_MODE or self.mode == COMPACT_MODE
       -- Type column in Address list
       AddressList.Header.Sections[3].Visible = self.mode == STANDARD_MODE or self.mode == COMPACT_MODE
     end

     function _m:cycle()

       if self.mode == COMPACT_MODE then
         self.mode = STANDARD_MODE
       elseif self.mode == STANDARD_MODE then
         self.mode = COMPACT_MODE
       end
       self:_update()
     end

     function _m:standard()
       self.mode = STANDARD_MODE
       self:_update()
     end


     function _m:compact()
       self.mode = COMPACT_MODE
       self:_update()
     end


     local parent = getMainForm().Menu.Items
     local menu_item = createMenuItem(parent)
     menu_item.OnClick = function() _m:cycle() end
     parent.add(menu_item)

     _m.menu_item = menu_item
     _m:compact()

     return _m
   end

   require("ce")

   local sform = getMainForm()

   control_setCaption(sform , "Hexinton")
end
synchronize(init)

if getProcessIDFromProcessName("nightreign.exe") ~= nil then
   if getProcessIDFromProcessName('EasyAntiCheat_EOS.exe') or getProcessIDFromProcessName('EasyAntiCheat')then
      error('Easy Anti-Cheat is still runnign you need to start the game with the provided bat file')
      print('Easy Anti-Cheat is still runnign you need to start the game with the provided bat file')
   else
      openProcess("nightreign.exe")
   end
else
   error("Unable to find game")
   print("Unable to find game")
end

setGlobalDelayBetweenHotkeyActivation(50)

local WorldChrManAob= AOBScanModuleUnique("nightreign.exe","48 8B 05 ???????? 0F 28 F1 48 85 C0","+X")
registerSymbol("WorldChrMan",WorldChrManAob+7+readInteger(WorldChrManAob+3,true),true)

local GameDataManAob= AOBScanModuleUnique("nightreign.exe","48 8B 0D ???????? F3 48 0F 2C C0","+X")
registerSymbol("GameDataMan",GameDataManAob+7+readInteger(GameDataManAob+3,true),true)

local CSWindowAob= AOBScanModuleUnique("nightreign.exe","48 8B 0D ???????? 0F 5B C0 0F 5B C9","+X")
registerSymbol("CSWindow",CSWindowAob+7+readInteger(CSWindowAob+3,true),true)

local CSFlipperAob= AOBScanModuleUnique("nightreign.exe","48 8B 05 ???????? 48 85 C0 ???? 4C 8B 05 ???????? 4C 89 44 24 60 8D 50 08 B9","+X")
registerSymbol("CSFlipper",CSFlipperAob+7+readInteger(CSFlipperAob+3,true),true)

local SoloParamRepositoryAob=AOBScanModuleUnique("nightreign.exe", "48 8B ? ? ? ? ? 48 85 ? 75 ? 48 8D ? ? ? ? ? E8 ? ? ? ? 4C 8B ? 4C 8D ? ? ? ? ? BA ? ? ? ? 48 8D ? ? ? ? ? E8 ? ? ? ? 48 8B ? ? ? ? ? 45 33 ? 41 8D ? ? E8 ? ? ? ? 48 85 ? 0F 84 ? ? ? ? 48 8B ? ? ? ? ? 48 8B ? ? ? ? ? 48 8D ? ? ? ? ? 48 89 ? ? 48 89", "+X")
registerSymbol("SoloParamRepository",SoloParamRepositoryAob+7+readInteger(SoloParamRepositoryAob+3,true),true)

local CSGaitemAob= AOBScanModuleUnique("nightreign.exe","8B 03 89 44 24 40 48 8B 0D ???????? 48 85 C9","+X")
registerSymbol("CSGaitem",CSGaitemAob+13+readInteger(CSGaitemAob+9,true),true)

local EventFlagAob= AOBScanModuleUnique("nightreign.exe","48 8B 1D ???????? 49 8B F0 48 8B F9","+X")
registerSymbol("EventFlag",EventFlagAob+7+readInteger(EventFlagAob+3,true),true)

registerSymbol("EventFlagBaseA", AOBScanModuleUnique("nightreign.exe","48 89 5C 24 08 44 8B 49 1C 44","+X"),true)

registerSymbol("Money", AOBScanModuleUnique("nightreign.exe","44 8B 81 ???????? 4C 8B D1 B9","+X"),true)

registerSymbol("MainPlayerOffset","174e8")
-------------Money
howMoney = getAddressSafe(allocateMemory(0x1000, getAddress("nightreign.exe")))
-------------param
ParamBaseV4={}
ParamNameV4={}
ParamCacheV4={}
ParamBase=readQword("SoloParamRepository")
local addrlist=getAddressList()
ParamID=allocateMemory(0x1000)
Gaitem = getAddressSafe(allocateMemory(0x1000, getAddress("nightreign.exe")))
-------------param
function GetParamTable(Index)--0:weapon 1:armor 2:talisman 3:goods 10:bullet 14:magic
    local hdr=readQword(ParamBase+Index*72+0x88)
    if not hdr then return nil end
    return readQword(readQword(hdr+0x80)+0x80),readString(readQword(hdr+24),64,true)
end

function getValue(t,k,def)
    local v=t[k]
    if v then
       return v
    end
    return def
end

function GetParamStructSize(TableBase)
    return readInteger(TableBase+0x48+24)-readInteger(TableBase+0x48)
end

function LoadParamTable(TableBase)
   if not TableBase then return nil end
   local n=readSmallInteger(TableBase+10)
   if not n then return nil end
   local tbl={}
   for i=0,n-1 do
       tbl[readInteger(TableBase+64+24*i)]=TableBase+readInteger(TableBase+64+24*i+8)
   end
   return tbl
end

local function getValidId(TableBase)
   if not TableBase then return nil end
   return readInteger(TableBase+64+24*0)
end

for i=0,90 do --244
local tb=addrlist.getMemoryRecordByID(4030000+i*10)
local id=addrlist.getMemoryRecordByID(4030001+i*10)
   if i ~= 40 and i ~= 45 and i ~= 46 and i ~= 61 and i ~= 178 and i ~= 245 then
   ParamBaseV4[i],ParamNameV4[i]=GetParamTable(i)
      if ParamBaseV4[i] then
      ParamCacheV4[i]=LoadParamTable(ParamBaseV4[i])
         if getValidId(ParamBaseV4[i]) then
         writeInteger(ParamID+4*i,getValidId(ParamBaseV4[i]))
         tb.Address=string.format("%X",ParamBaseV4[i])
         id.Address=string.format("%X",ParamID+4*i)
         end
      end
   end
end

function UpdateParamAddress()
    --ppv4
    for i=0,90 do
       if i ~= 40 and i ~= 45 and i ~= 46 and i ~= 61 and i ~= 178 and i ~= 245 then
        local datarec=addrlist.getMemoryRecordByID(4030002+i*10)
        if datarec then
           datarec.Address=string.format("%X",getValue(ParamCacheV4[i],readInteger(ParamID+4*i),0))
        end
       end
    end
    writeSmallInteger("Gaitem",readSmallInteger("[[gamedataman]+8]+2e8"))
    writeSmallInteger("Gaitem+4",readSmallInteger("[[gamedataman]+8]+2ec"))
    writeSmallInteger("Gaitem+8",readSmallInteger("[[gamedataman]+8]+2f0"))
    --end
end

RefreshTimer=createTimer(getMainForm())
RefreshTimer.Interval=512
RefreshTimer.OnTimer=function(timer)
    if not pcall(UpdateParamAddress) and not openProcess("nightreign.exe") then
       addrlist.getMemoryRecordByID(601248).Active=false
    end
end
RefreshTimer.OnTimer(RefreshTimer)

function GetValidIDs(index)
   local TableBase,TableName=GetParamTable(index)
   if not TableBase then return nil end
   local n=readSmallInteger(TableBase+10)
   if not n then return nil end
   local dropdownstring=string.format('All Valid IDs - %u - %s\n',index,TableName)
   for i=0,n-1 do
       local id=tostring(readInteger(TableBase+64+24*i))
       dropdownstring=dropdownstring..id..'\n'
   end
   dropdownstring=dropdownstring..string.format("END - %u - %s",index,TableName)
   local filename=os.getenv("TEMP")..string.format("\\%s.txt",TableName)
   file = io.open(filename, "w")
   io.output(file)
   io.write(dropdownstring)
   io.close(file)
   ShellExecute(filename)
   return dropdownstring
end

function SaveParam(index)
local id = readInteger(ParamID+4*index) -- 4*index
local addr = ParamCacheV4[index][id]
local paramlength = readInteger(ParamBaseV4[index]+0x48+24)-readInteger(ParamBaseV4[index]+0x48)
local addrname = string.format("%sAddr_%u",ParamNameV4[index],id)
local rTableName = string.format("%sRestore_%u",ParamNameV4[index],id)
local s = "local function f()\n"
s = s .. addrname .. string.format(" = ParamCacheV4[%u][%u]\n",index,id)
s = s .. rTableName .. string.format(" = readBytes(%s,%d,true)\n",addrname,paramlength)
s = s .. string.format("writeBytes(%sAddr_%u,{",ParamNameV4[index],id)
for i=0,paramlength-1 do
s = s .. tostring(readBytes(addr+i))
  if i&lt;paramlength-1 then
  s = s .. ','
  end
end
s = s .. '})\nend'
print(s)
local fstr = loadstring(s .. "\nreturn encodeFunction(f)")()
fstr = "decodeFunction(\""..fstr.."\")()"
fstr = "{This script is generated by ParamPatcherV3}\n[ENABLE]\n{$lua}\n"..fstr.."\n[DISABLE]\n{$lua}\n"..string.format("writeBytes(%s,%s)",addrname,rTableName)

local newmemrec=getAddressList().createMemoryRecord()
newmemrec.appendToEntry(getAddressList().getMemoryRecordByID(1337096981))
newmemrec.Type=vtAutoAssembler
newmemrec.Script=fstr
newmemrec.description=string.format("%sScript_%u",ParamNameV4[index],id)
end


function writeBit(addr, offset, toggle)
  local bit = readByte(addr)
  local dd_flag = readInteger("[[WorldChrMan]+80]+70")
  if bit then
    if true then
      local mask = 1 &lt;&lt; offset
      local isSet = (bit &amp; mask) ~= 0
      local flag = type(toggle) == "number" and (toggle == 0 and bit &amp; ~ mask or bit | mask) or isSet
      writeByte(addr, flag)
    end
  end
end

function readBit(addr, offset)
    local bit = readByte(addr)
    if bit then
        local mask = 1 &lt;&lt; offset
        if (bit &amp; mask) ~= 0 then return 1
        else return 0 end
    end
    return false
end

function disableMemrec(memrec, delay)
  local memrecType = type(memrec)
  if memrecType == "userdata" then
    -- noop, we assume it is already MemoryRecord
  elseif memrecType == "string" then
    memrec = getAddressList().getMemoryRecordByDescription(memrec)
  elseif memrecType == "number" then
    memrec = getAddressList().getMemoryRecordByID(memrec)
  end
  if not memrec then return end
  local t = createTimer(nil)
  delay = delay or 100
  local delayType = type(delay)
  if delayType == "string" then
    t.interval = 100
    t.onTimer = function(t)
      if readBytes(delay, 1) == 1 then
        t.destroy()
        memrec.active = false
      end
    end
  elseif delayType == "number" then
    -- minimum delay is 0.1 seconds
    t.interval = math.max(delay, 100)
    t.onTimer = function(t)
      t.destroy()
      memrec.active = false
    end
  elseif delayType == "function" then
    t.interval = 100
    t.onTimer = function(t)
      if delay() then
        t.destroy()
        memrec.active = false
      end
    end
  end
end

Timer = {}

function Timer:new(int, func, state)
  local o = {
    timer = createTimer()
  }
  if int &lt;= 0 then int = 20 end
  o.timer.Interval = int
  o.timer.OnTimer = func
  if state == true or state == 1 then
    o.timer.Enabled = true
  elseif state == false or state == 0 then
    o.timer.Enabled = false
  else
    o.timer.Enabled = true
  end
  self.__index = self
  return setmetatable(o, self)
end

function Timer:kill()
  if self.timer then
    self.timer.destroy()
  end
end

function Timer:setInterval(int)
  if self.timer then
    if int &lt;= 0 then int = 20 end
    self.timer.Interval = int
  end
end

function Timer:setState(state)
  if self.timer then
    if state == true or state == 1 then
      self.timer.Enabled = true
    elseif state == false or state == 0 then
      self.timer.Enabled = false
    end
  end
end

function Timer:isTimer()
  if self.timer then
    return true
  else
    return false
  end
end

function delay(func, time)
  local timer = createTimer()
  timer.Interval = time or 100
  timer.OnTimer = function()
    timer.destroy()
    func()
  end
end

function onceText(str, time)
  GetLuaEngine().MenuItem5.doClick()
  print(str)
  delay(function()
    GetLuaEngine().MenuItem5.doClick()
    GetLuaEngine().close()
  end, (time or 800))
end

function playYes()
  return readInteger("[[WorldChrMan]+MainPlayerOffset]+1b8") ~= nil
end

function SetHp(hp)
if hp == max then writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+140",readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+144"))
  else writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+140",hp) end
end

function SetFp(fp)
if fp == max then writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+150",readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+154"))
  else writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+150",fp) end
end

function SetStamina(s)
if s == max then writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+15c",readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+160"))
  else writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+15c",s) end
end

function GetHP()
 return readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+140")
end

function GetFP()
 return readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+150")
end

function GetStamina()
 return readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+0]+15c")
end

function GetAnim()
 return readInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+80]+98")
end

function NoHitBox(mode)
  if mode&gt;0 then writeByte("[[[WorldChrMan]+MainPlayerOffset]+60]+f8",1)
    else writeByte("[[[WorldChrMan]+MainPlayerOffset]+60]+f8",0) end
end

function UnlockFpsLimit(mode)
if mode&gt;0 then writeByte("[CSFlipper]+8",6)
    else writeByte("[CSFlipper]+8",5) end
end

function SetSpeed(speed)
  writeFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+28]+1818",speed)
end

function PlayAnimByNumericalId(id)
  writeInteger("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+58]+18",id)
end

function NoGravity(y)
  if y&gt;0 then writeBit("[[WorldChrMan]+MainPlayerOffset]+1f2",5,1)
    else writeBit("[[WorldChrMan]+MainPlayerOffset]+1f2",5,0)end
end

function getX()
  return readFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+70")
end

function getY()
  return readFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+74")
end

function getZ()
  return readFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+78")
end

function setX(x)
  writeFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+70",x)
end

function setY(y)
  writeFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+74",y)
end

function setZ(z)
  writeFloat("[[[[WorldChrMan]+MainPlayerOffset]+1b8]+68]+78",z)
end

function SetEventFlag(flag,on)
  executeCodeEx(0,0,"EventFlagBaseA",readQword("EventFlag"),flag,on)
end

function BCD(b)
  if b&gt;0 and myYes() then writeFloat("[[[[worldchrman]+MainPlayerOffset]+1b8]+148]+18",0)end
end

function haveL()
  return readByte("[[[[worldchrman]+MainPlayerOffset]+1b8]+148]+20")
end

function havL(l)
  if l&gt;0 and myYes() then writeByte("[[[[worldchrman]+MainPlayerOffset]+1b8]+148]+20",1)end
end

function LCD(l)
  if l&gt;0 and myYes() then writeFloat("[[[[worldchrman]+MainPlayerOffset]+1b8]+148]+2c",0)end
end

function giveMoney(y)
if y==0 then y =99999 end
  executeCodeEx(0,0,"Money",readQword("[GameDataMan]+8"),y)
end

PlayerMan = getAddressSafe(allocateMemory(128, getAddress("nightreign.exe")))

writeInteger("PlayerMan",1)
writeInteger("PlayerMan+4",0)
writeInteger("PlayerMan+8",0)
writeInteger("PlayerMan+c",0)
writeInteger("PlayerMan+10",0)
writeInteger("PlayerMan+14",0)
writeInteger("PlayerMan+18",0)
writeInteger("PlayerMan+1c",0)

PlayMan={
{50000,50010,50020,50030,50050,50060},
{50100,50110,50120,50130,50150,50160},
{50200,50210,50220,50230,50250,50260},
{50300,50310,50320,50330,50350,50360},
{50400,50410,50420,50430,50450,50460},
{50500,50510,50520,50530,50550,50560},
{50600,50610,50620,50630,50650,50660},
{50700,50710,50720,50730,50750,50760}
}

function retRevise(who)
local retPlay={}
   for i,k in pairs(PlayMan[who])do
      retPlay[k]=readBytes(ParamCacheV4[24][k],GetParamStructSize(ParamBaseV4[24]),true)
   end
   return retPlay
end

allret={}
for i=1,8 do
   allret[i]=retRevise(i)
end

function goback(who,backupData)
   for i,k in ipairs(PlayMan[who])do
      writeBytes(ParamCacheV4[24][k],backupData[k])
   end
end

function Revise(rwp1,lwp1,rwp2,lwp2,ring1,ring2,lv,who,skipCreater)
   if skipCreater then
      for i,k in ipairs(PlayMan[who]) do
      if  rwp1~=0 then
         writeInteger(ParamCacheV4[24][k]+0x4,rwp1)
      end
      if  lwp1~=0  then
         writeInteger(ParamCacheV4[24][k]+0xC,lwp1)
      end
      if  rwp2~=0  then
         writeInteger(ParamCacheV4[24][k]+0x10,rwp2)
      end
      if  lwp2~=0  then
         writeInteger(ParamCacheV4[24][k]+0x8,lwp2)
      end
      if  ring1~=0  then
         writeInteger(ParamCacheV4[24][k]+0x40,ring1)
      end
      if  ring2~=0  then
         writeInteger(ParamCacheV4[24][k]+0x3c,ring2)
      end
      if  lv~=0  then
         writeSmallInteger(ParamCacheV4[24][k]+0xB4,lv)
      end
      end
   end
end

[DISABLE]
if debug_isDebugging() then detachIfPossible() end
deleteAllRegisteredSymbols()
openProcess('cheatengine')
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>5</ID>
          <Description>"血量"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>worldchrman</Address>
          <Offsets>
            <Offset>140</Offset>
            <Offset>0</Offset>
            <Offset>1B8</Offset>
            <Offset>MainPlayerOffset</Offset>
          </Offsets>
        </CheatEntry>
        <CheatEntry>
          <ID>6</ID>
          <Description>"最大血量上限"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>worldchrman</Address>
          <Offsets>
            <Offset>144</Offset>
            <Offset>0</Offset>
            <Offset>1B8</Offset>
            <Offset>MainPlayerOffset</Offset>
          </Offsets>
        </CheatEntry>
        <CheatEntry>
          <ID>4</ID>
          <Description>"等级"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>GameDataMan</Address>
          <Offsets>
            <Offset>68</Offset>
            <Offset>08</Offset>
          </Offsets>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>